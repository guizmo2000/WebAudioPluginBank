<template id="wasabi-host">
  <div id="wasabi-content">
  </div>
</template>
<script>

  var hosts = hosts || {};
  let importDoc = document.currentScript.ownerDocument;
  let template = importDoc.querySelector("#wasabi-host");

  class WasabiHost extends HTMLElement {
    constructor() {
      super();
      this._root = this.attachShadow({ mode: 'open' });
      this._root.appendChild(template.content.cloneNode(true));
      this.ctx = "";
      this._inited = false;
    }

    init(className) {
      console.log(className);
      return new Promise(function (resolve, reject) {
        let ctx = self.ctx;
        if (!ctx) {
          ctx = new AudioContext();
        } else {
          self.ctx = ctx;
        }
        var hostsClass = hosts[className];
        var plug = new hostsClass(ctx);
        resolve(plug);
      });
    }

    // in faust there is no global processor but one for each plugin. --> issue : how to make this loader generic
    initFaust(className) {
      console.log("initFaust");
      console.log(className);
      // The main global scope
      return new Promise(function (resolve, reject) {
        let ctx = self.ctx;
        if (!ctx) {
          ctx = new AudioContext();
        } else {
          self.ctx = ctx;
        }
        console.log("in creatzitaRev/zitaRev.js")
        var hostsClass = hosts[className];
        var plug;
        // The main global scope
        faust = self.ctx.audioWorklet.addModule("faust-zitaRev-aw-files/zitaRev-processor.js").then(function () {
          try {
            plug = new hostsClass(self.ctx, {});
            return (plug);
          } catch (error) {
            console.log(error); console.log("Faust zitaRev cannot be loaded or compiled");
          }
        });
        resolve(faust);
      });
    }


    load(url, className, flag) {
      var self = this;
      var plug;
      return new Promise(function (resolve, reject) {
        function loaded() {
          if (!className) {

            var tokens = url.split("/");
            className = tokens[tokens.length - 1].split(".")[0];
          }
          // temporary distinction before unifying the code
          if (url.includes("Faust") || url.includes("faust")) {
            self.initFaust(className).then((wasabi) => {
              var detail = { url: url, wasabi: wasabi, status: 200 }
              var event = new CustomEvent("load", { detail: detail });
              self.dispatchEvent(event);
              if (url.endsWith(".html")) {
                let wc = document.createElement(this.import.head.querySelector("template").id);
                let content = self.shadowRoot.getElementById("wasabi-content");
                wc.plug = wasabi;
                content.appendChild(wc);
              }
              resolve(wasabi);
            });
          } else {
            self.init(className).then((wasabi) => {
              var detail = { url: url, wasabi: wasabi, status: 200 }
              var event = new CustomEvent("load", { detail: detail });
              self.dispatchEvent(event);
              if (url.endsWith(".html")) {
                let wc = document.createElement(this.import.head.querySelector("template").id);
                let content = self.shadowRoot.getElementById("wasabi-content");
                wc.plug = wasabi;
                content.appendChild(wc);
              }
              resolve(wasabi);
            });

          }

        }


        if (url.endsWith(".js")) {
          var script = document.createElement('script');
          script.src = url;
          script.onload = loaded;
          document.head.appendChild(script);
        }
        else if (url.endsWith(".html")) {
          var link = document.createElement('link');
          link.rel = 'import';
          link.id = 'urlPlugin';
          link.href = url;
          link.onload = loaded;
          document.head.appendChild(link);
        }
        else reject("invalid argument");
      });
    }
  }




  window.customElements.define('wasabi-host', WasabiHost);


</script>